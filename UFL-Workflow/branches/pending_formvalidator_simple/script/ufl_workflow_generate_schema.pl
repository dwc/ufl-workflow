#!/usr/bin/env perl

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../lib";
use UFL::Workflow::Schema;

=head1 NAME

ufl_workflow_generate_schema.pl - Generate the schema for UFL::Workflow

=head1 SYNOPSIS

    ./script/ufl_workflow_generate_schema.pl | db2 -vtd%

=head1 DESCRIPTION

Generate the SQL statements for L<UFL::Workflow::Schema>.

=head1 AUTHOR

Daniel Westermann-Clark E<lt>dwc@ufl.eduE<gt>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

my $type = $ARGV[0] || 'DB2';
my $separator = $ARGV[1] || '%';
my $user = $ARGV[2] || 'dbzwap02';

my $schema = UFL::Workflow::Schema->connect;
my @statements = $schema->storage->deployment_statements($schema, $type, undef, undef, { add_drop_table => 1 });

# Add update triggers here since they can't be declared on the schema
if ($type eq 'DB2') {
    my $field_name = 'update_time';

    foreach my $source_name ($schema->sources) {
        my $source = $schema->source($source_name);
        my $table_name = $source->from;

        # Grant permissions
        my $grant = <<"END_OF_SQL";
GRANT DELETE, INSERT, SELECT, UPDATE
ON TABLE $table_name
TO USER $user;
END_OF_SQL

        chomp $grant;
        push @statements, $grant;

        # Set up triggers
        next unless $source->has_column($field_name);

        my $trigger_name = "${table_name}_u";
        if (length $trigger_name > 18) {
            my $new_trigger_name = $trigger_name;
            $new_trigger_name =~ s/([A-Za-z])[A-Za-z]+_/$1_/g;

            warn "Shortening trigger [$trigger_name] to [$new_trigger_name]";
            $trigger_name = $new_trigger_name;
        }

        my $drop = "DROP TRIGGER $trigger_name;";
        my $create = <<"END_OF_SQL";
CREATE TRIGGER $trigger_name
NO CASCADE BEFORE UPDATE ON $table_name
REFERENCING NEW AS n
FOR EACH ROW MODE DB2SQL
SET n.$field_name = CURRENT TIMESTAMP;
END_OF_SQL

        chomp $create;
        push @statements, $drop, $create;
    }

    # Set the separator (due to the requests_action_u trigger)
    s/;/$separator/g for @statements;

    # Set up one more trigger to update the request timestamp when the action is updated
    push @statements, "DROP TRIGGER requests_action_u$separator";
    push @statements, <<"END_OF_SQL";
CREATE TRIGGER requests_action_u
AFTER UPDATE ON actions
REFERENCING NEW as n
FOR EACH ROW MODE DB2SQL
BEGIN ATOMIC
  UPDATE requests SET $field_name = CURRENT TIMESTAMP WHERE id = n.request_id;
END$separator
END_OF_SQL
}

print "--\n";
print "-- Generated by $0 on " . scalar(localtime) . "\n";
print "--\n";
print "\n";
print join "\n\n", @statements;
print "\n";
